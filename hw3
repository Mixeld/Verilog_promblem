module fdiv_1hz (
    input clk_100mhz,
    input rst,
    output reg clk_1hz
);

    parameter N = 26;
    reg [N-1:0] counter;

    always @(posedge clk_100mhz or posedge rst) begin
        if (rst) begin
            counter <= 0;
            clk_1hz <= 0;
        end
        else begin
            // 100 МГц / 1 Гц = 100_000_000 тактов.
            // Переключение каждые 50_000_000 тактов дает полный период 1 сек.
            if (counter == 50_000_000 - 1) begin
                counter <= 0;
                clk_1hz <= ~clk_1hz;
            end
            else begin
                counter <= counter + 1;
            end
        end
    end
endmodule

module fdiv_k_vector #(
    parameter K_WIDTH = 8,          // Разрядность шины k
    parameter COUNTER_WIDTH = 32    // Максимальная разрядность счетчика
)(
    input wire clk,
    input wire rst,
    
    // Входной вектор k. В top_module мы подадим сюда константу.
    input wire [K_WIDTH-1:0] k_switches,
    
    output reg clk_out
    
    // Если нужны отладочные выходы, их нужно раскомментировать здесь:
    // , output wire [COUNTER_WIDTH-1:0] counter_debug
    // , output wire divider_active
);
    
    reg [K_WIDTH-1:0] k_reg;
    reg [COUNTER_WIDTH-1:0] counter;
    wire k_nonzero;
    
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            k_reg <= 0;
        end
        else begin
            k_reg <= k_switches;
        end
    end
    
    assign k_nonzero = (k_reg != 0);
    
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            counter <= 0;
            clk_out <= 0;
        end
        else if (!k_nonzero) begin
            counter <= 0;
            clk_out <= 0;
        end
        else begin
            // Логика: переключаем выход каждые k тактов.
            // Период будет равен 2 * k * (период входного клока).
            if (counter >= k_reg - 1) begin
                counter <= 0;
                clk_out <= ~clk_out; 
            end
            else begin
                counter <= counter + 1;
            end
        end
    end
    
    // Если порты не добавлены в output модуля, эти assign вызовут ошибку.
    // Я их закомментировал для чистоты кода.
    // assign counter_debug = counter;
    // assign divider_active = k_nonzero;
    
endmodule

module top_module (
    input clk_100mhz,
    input reset_btn,
    output [1:0] leds
);
    wire clk_1hz;
    wire clk_slow;
    
    // 1. Делитель 100 МГц -> 1 Гц
    fdiv_1hz div1 (
        .clk_100mhz(clk_100mhz),
        .rst(reset_btn),
        .clk_1hz(clk_1hz)
    );
    
    // 2. Делитель на K.
    // Мы хотим, чтобы он делил на 8.
    // Так как clk_1hz уже медленный, этот модуль будет использовать его как clock.
    fdiv_k_vector #(
        .K_WIDTH(8)       // Указываем ширину, а не значение делителя
    ) div2 (
        .clk(clk_1hz),    // Исправлено имя порта: clk вместо clk_in
        .rst(reset_btn),
        .k_switches(8'd8),// ПЕРЕДАЕМ ЗНАЧЕНИЕ 8 СЮДА (статически)
        .clk_out(clk_slow)
    );
    
    // Индикация
    assign leds[0] = clk_1hz;     // Мигает (вкл/выкл) 1 раз в секунду
    assign leds[1] = clk_slow;    
    // При k=8 выход переключается каждые 8 секунд.
    // Полный период (вкл + выкл) = 16 секунд.
    
endmodule
